#include<iostream>
#include<chrono>
#include<cstdlib>
#include<algorithm>
using namespace std;
using namespace std::chrono;

struct lectures {
    int start_time;
    int end_time;
};

bool compare_end_time(lectures &l1, lectures &l2) {
    return l1.end_time < l2.end_time;
}

int selection(lectures *lec, int n) {
    if (n == 0) {
        return 0;
    }

    sort(lec, lec + n, compare_end_time);
    int i = 0, j;
    int solution = 1;
    for (j = 1; j < n; j++) {
        if (lec[j].start_time < lec[i].end_time) {
            
        } else {
            solution++;
            i = j;
        }
    }
    return solution;
}

lectures* generate_items(int n) {
    lectures* lect = new lectures[n];
    for (int j = 0; j < n; j++) {
        lect[j].start_time = rand() % 23; 
        int max_duration = min(24 - lect[j].start_time, 1); 
        if (max_duration > 0) {
            lect[j].end_time = (lect[j].start_time + rand() % max_duration) % 24 + 1; 
        } else {
            lect[j].end_time = lect[j].start_time + 1;
        }
    }
    return lect;
}

int main() {
    for (int i = 100; i <= 700; i += 50) {
        lectures* lect = generate_items(i);

        auto start = high_resolution_clock::now();

        for (int m = 1; m <= 10; m++) {
            selection(lect, i);
        }

        auto stop = high_resolution_clock::now();
        int max_lectures = selection(lect, i);
        auto duration = duration_cast<nanoseconds>(stop - start) / 10;

        cout << i << "\t" << duration.count() << "\t" << "max_lectures = " << max_lectures << endl;

        delete[] lect;
    }

    return 0;
}
